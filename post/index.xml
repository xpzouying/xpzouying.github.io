<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on zouying.is</title>
    <link>https://xpzouying.github.io/post/</link>
    <description>Recent content in Posts on zouying.is</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>© This post is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License，please give source if you likes to quote or reproduce.</copyright>
    <lastBuildDate>Sat, 03 Feb 2018 17:44:05 +0800</lastBuildDate>
    
	<atom:link href="https://xpzouying.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>06_read_line_by_line_in_golang</title>
      <link>https://xpzouying.github.io/post/06_read_file_line_by_line_in_golang/</link>
      <pubDate>Sat, 03 Feb 2018 17:44:05 +0800</pubDate>
      
      <guid>https://xpzouying.github.io/post/06_read_file_line_by_line_in_golang/</guid>
      <description>前段时间需要使用Go按行分析日志文件，比较常用的有两种方式。
 使用bufio.Scanner进行按行扫描；
 使用bufio.Reader中ReadString/ReadBytes/&amp;hellip;一行一行读取；
  分析日志文件250M左右大小，文件大约在250w行。
func scanFile() { f, err := os.OpenFile(logfile, os.O_RDONLY, os.ModePerm) if err != nil { log.Fatalf(&amp;#34;open file error: %v&amp;#34;, err) return } defer f.Close() total := 0 // count lines  begin := time.Now() defer func() { log.Printf(&amp;#34;scan file, time_used: %v, lines=%v\n&amp;#34;, time.Since(begin).Seconds(), total) }() sc := bufio.NewScanner(f) for sc.Scan() { _ = sc.Text() total++ } if err := sc.Err(); err != nil { log.</description>
    </item>
    
    <item>
      <title>Basic of Interview</title>
      <link>https://xpzouying.github.io/post/04_interview/</link>
      <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xpzouying.github.io/post/04_interview/</guid>
      <description> Note for Interview 死锁  http://blog.csdn.net/yanxiaolx/article/details/51944048 http://wdxtub.com/interview/14520847747820.html https://www.cnblogs.com/loveyakamoz/archive/2012/11/14/2770812.html  死锁是指两个或多个线程／进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程／进程。
死锁的4个必要条件 - 资源是互斥，不能共享，只能被一个进程使用 - 请求并保持：一个进程已经请求得到至少一个资源后，又提出新的资源请求，而请求的资源被其他占用，此时请求进程阻塞，但是又不释放已经占有的资源。 - 资源分配后不可剥夺 - 循环等待：发生死锁时，必然循环等待的环形链。  产生死锁的原因 - 资源之间存在竞争 - 资源不够 - 资源分配的顺序不对，导致产生循环等待  解决死锁的方法 预防死锁 破坏产生死锁的四个必要条件
 资源互斥性：这个没有办法破坏 请求并保持资源：资源一次性分配 资源不可剥夺：申请资源后的可剥夺 循环等待：有需分配  避免死锁 银行家算法
检测死锁 为每个进程和资源分配唯一的ID，建立资源分配表和进程等待表
解除死锁  剥夺资源 撤销进程：直接撤销死锁进程或者撤销代价最小的进程，直到拥有足够的资源可用，解除死锁为止。  TCP/IP 协议  http://blog.csdn.net/monkeynote/article/details/45868085 ZY: MUST READ!!! UDP vs.TCP Which protocol is best for games? https://gafferongames.com/post/udp_vs_tcp/ 从输入 URL 到页面加载完成的过程中都发生了什么事情？ Beej&amp;rsquo;s Guide to Network Programming Using Internet Sockets 链接中有中文版 通俗大白话来理解TCP协议的三次握手和四次分手 #14 前端经典面试题: 从输入URL到页面加载发生了什么？  TCP vs UDP TCP: - 有连接的 - 可靠性和顺序保证 - 自动将你的数据分成Packets（IP层的数据包） - 确保数据在网络中不会发送的太快 (流量控制) - 容易使用，像读写文件一样  UDP： - 没有连接的概念，需要自己主机到主机的维护 - 没有可靠性和按序到达的保证，数据包到达时可能乱序、重复，也可能完全丢失 - 需要自己切分成合适的Packets（add：UDP包有大小限制，控制在548字节以内，大了有丢包风险） - 需要自己在程序逻辑中确保发包速度不能太快（add：发包频率一定要控制，速度开也增大丢包风险） - 需要自己在程序逻辑中实现丢包重传  </description>
    </item>
    
    <item>
      <title>Web service middleware in Golang</title>
      <link>https://xpzouying.github.io/post/05_middleware_in_golang/</link>
      <pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xpzouying.github.io/post/05_middleware_in_golang/</guid>
      <description>有时候我们需要统计web service接口的数据，比如记录日志、统计API调用时间、或者对HandleFunc进行错误处理，
这个时候，middleware就很有帮助。
最初版本 我们目前有个程序，监听8080端口，提供两个接口，
1. compute：进行计算，耗时在500ms-1000ms之间 2. version：得到版本号，耗时在10ms-60ms之间  package main import ( &amp;#34;log&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;net/http&amp;#34; &amp;#34;time&amp;#34; ) // Compute is compute process for doing task func Compute(w http.ResponseWriter, r *http.Request) { time.Sleep(time.Duration((500 + rand.Intn(500))) * time.Millisecond) } // Version is getting version task func Version(w http.ResponseWriter, r *http.Request) { time.Sleep(time.Duration((10 + rand.Intn(50))) * time.Millisecond) w.Write([]byte(&amp;#34;version&amp;#34;)) } func main() { http.HandleFunc(&amp;#34;/compute&amp;#34;, Compute) http.HandleFunc(&amp;#34;/version&amp;#34;, Version) log.Panic(http.ListenAndServe(&amp;#34;:8080&amp;#34;, nil)) } 调用结果如下，</description>
    </item>
    
    <item>
      <title>TCP网络编程分析：C语言篇</title>
      <link>https://xpzouying.github.io/post/03_c_tcp_program/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xpzouying.github.io/post/03_c_tcp_program/</guid>
      <description>TCP网络编程分析：C语言篇 Link: - https://xpzouying.github.io/post/03_c_tcp_program/ - source code in github.com/xpzouying
参考《Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)》
网络模型
client端 主要功能：
client通过tcp访问server，获得服务器时间。
主要代码如下：
int main(int argc, char **argv) { int	sockfd, n; char	recvline[MAXLINE + 1]; struct sockaddr_in	servaddr; if (argc != 2) err_quit(&amp;#34;usage: a.out &amp;lt;IPaddress&amp;gt;&amp;#34;); if ( (sockfd = socket(AF_INET, SOCK_STREAM, 0)) &amp;lt; 0) err_sys(&amp;#34;socket error&amp;#34;); bzero(&amp;amp;servaddr, sizeof(servaddr)); servaddr.sin_family = AF_INET; servaddr.sin_port = htons(13);	/* daytime server */ if (inet_pton(AF_INET, argv[1], &amp;amp;servaddr.</description>
    </item>
    
    <item>
      <title>DIVE INTO GOLANG: bufio.Writer</title>
      <link>https://xpzouying.github.io/post/02_dive_into_golang_io_writer/</link>
      <pubDate>Sat, 25 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xpzouying.github.io/post/02_dive_into_golang_io_writer/</guid>
      <description>介绍 bufio实现了I/O的缓存，为io.Reader或io.Writer提供I/O缓存。
为什么需要bufio？ 以write()操作为例。
对于没有缓存的I/O操作，进行一次write()操作需要将用户空间(user space)中的数据传输到内核空间(kernel space)后，调用write()系统调用完成write操作，然后返回用户空间。
如果每个字节(single byte)都需要重复上述过程，那么写入过程就非常低效率。
为了解决该问题，就引入了用户空间的I/O缓存（user buffered I/O）。在用户空间中分配一块缓存区用来临时保存数据，当缓存写满后，再调用write()系统调用来写数据，从而提供效率。
Golang中bufio实现的功能就是类似的功能。为某个io.Writer或者io.Reader提供缓存。
bufio包中的主要类型 - type ReadWriter - type Reader - type Scanner - type Writer （本文介绍的对象）  type bufio.Writer 为io.Writer对象提供缓存。
type Writer struct { err error buf []byte	// 缓存空间 	n int // 统计已经缓存的数据个数 	wr io.Writer // 底层的io.Writer对象 } Writer为一个结构体，定义了一块缓存，为wr对象提供缓存，err、n是当前缓存的中间状态，其中n表示当前缓存的数据个数，用来统计缓存区的缓存个数和计算剩余缓存空间大小。
使用说明 bufio提供来2个工厂函数获得Writer
 func NewWriter(w io.Writer) *Writer func NewWriterSize(w io.Writer, size int) *Writer  看源码，bufio/bufio.go
func NewWriter(w io.</description>
    </item>
    
    <item>
      <title>Setup</title>
      <link>https://xpzouying.github.io/post/my-first-post/</link>
      <pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://xpzouying.github.io/post/my-first-post/</guid>
      <description>这里什么都还没有。</description>
    </item>
    
  </channel>
</rss>